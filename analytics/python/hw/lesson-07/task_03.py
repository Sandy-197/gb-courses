# Задание 3.
# Реализовать программу работы с органическими клетками, состоящими из ячеек.
# Необходимо создать класс Клетка.
# В его конструкторе инициализировать параметр, соответствующий количеству ячеек клетки (целое число).
# В классе должны быть реализованы методы перегрузки арифметических операторов:
# сложение (__add__()),
# вычитание (__sub__()),
# умножение (__mul__()),
# деление (__truediv__()).
#
# Данные методы должны применяться только к клеткам и выполнять
# увеличение, уменьшение, умножение и целочисленное (с округлением до целого) деление клеток, соответственно.
# Сложение. Объединение двух клеток.
# При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.
# Вычитание. Участвуют две клетки.
# Операцию необходимо выполнять только если разность количества ячеек двух клеток больше нуля,
# иначе выводить соответствующее сообщение.
# Умножение. Создаётся общая клетка из двух.
# Число ячеек общей клетки определяется как произведение количества ячеек этих двух клеток.
# Деление. Создаётся общая клетка из двух.
# Число ячеек общей клетки определяется как целочисленное деление количества ячеек этих двух клеток.
#
# В классе необходимо реализовать метод make_order(),
# принимающий экземпляр класса и количество ячеек в ряду.
# Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****...,
# где количество ячеек между \n равно переданному аргументу.
# Если ячеек на формирование ряда не хватает,
# то в последний ряд записываются все оставшиеся.
#
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5.
# Тогда метод make_order() вернёт строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5.
# Тогда метод make_order() вернёт строку: *****\n*****\n*****.

class Cell:
	def __init__(self, cell):
		self.cell = cell

	@property
	def cell(self):
		return self.__cell

	@cell.setter
	def cell(self, cell):
		try:
			if int(cell) > 0:
				self.__cell = int(cell)
			else:
				self.__cell = None
				exit("Не верный формат данных, количество клеток должно быть целым и больше нуля")
		except ValueError:
			self.__cell = None
			exit("Не верный формат данных, количество клеток должно быть целым и больше нуля")

	def make_order(self, in_row):
		"""Возвращает string с разбитыми по рядам клетками"""
		return ''.join(['*' * in_row + '\n' for _ in range(self.cell // in_row)]) + ('*' * (self.cell % in_row))

	def __add__(self, other):
		"""Возвещает объект Cell, как сумму двух объектов Cell"""
		try:
			return Cell(self.cell + other.cell)
		except TypeError:
			print(f"{'Первый' if self.cell is None else 'Второй'} объект не имеет клеток.")
			print(f"Сложение не возможно. Новый объект не создан")

	def __sub__(self, other):
		""" Возвещает объект Cell, как разность двух объектов Cell\n
			Если разность двух объектов меньше нуля, то выводиться сообщение об ошибке\n
			и объект не создается
		"""
		try:
			if self.cell > other.cell:
				return Cell(self.cell - other.cell)
			else:
				print("Не возможно вычесть, результат не может быть меньше нуля")
				print("Новый объект не создан!\n")
		except TypeError:
			print(f"{'Первый' if self.cell is None else 'Второй'} объект не имеет клеток.")
			print(f"Вычитание не возможно. Новый объект не создан")

	def __mul__(self, other):
		"""Возвещает объект Cell, как произведение двух объектов Cell"""
		try:
			return Cell(self.cell * other.cell)
		except TypeError:
			print(f"{'Первый' if self.cell is None else 'Второй'} объект не имеет клеток.")
			print(f"Умножение не возможно. Новый объект не создан")

	def __truediv__(self, other):
		"""	Возвещает объект Cell, как целочисленное деление двух объектов Cell"""
		try:
			if other.cell != 0:
				c = self.cell // other.cell
				if c != 0:
					return c
				else:
					print("Деление не возможно, так как в кол-во клеток у нового объекта равно нулю")
					print("Новый объект не создан!")
			else:
				print("Не возможно разделить, делитель не может быть меньше нулю")
				print("Новый объект не создан!\n")
		except TypeError:
			print(f"{'Первый' if self.cell is None else 'Второй'} объект не имеет клеток.")
			print(f"Деление не возможно. Новый объект не создан")

	def __str__(self):
		return f"{self.cell}"


cell_1 = Cell(20)
cell_2 = Cell(20)

print(cell_1 + cell_2)
print(cell_2 - cell_1)
print(cell_1 * cell_2)
print(cell_1 / cell_2)

print(cell_1.make_order(8))
print(cell_2.make_order(3))
